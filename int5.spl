//int 5

alias physicalSP S0;
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);

if ([physicalSP - 1] == 8) then //fork
	alias count S1;
	alias child_pid S2;
	alias flag S3;
	alias parent_pid S4;
	parent_pid = (PTBR - 1024)/8;
	count = 0;
	flag =0;

	while (count < 32) do
		if ([READY_LIST + count*32 + 1] == 0 ) then //checking for free pcb entry
			child_pid = count;
			flag = 1;
			break;
		endif;
		count = count + 1;
	endwhile;

	if (flag == 0) then
		[physicalSP - 2] = -1;  //no free pcb entry
		ireturn;
	endif;

	[READY_LIST + child_pid*32] = child_pid;

	count = 0 ;
	flag = 0;
	alias mem_free S5;
	mem_free = 0;

	while (count < 64) do
		if([MEM_LIST + count] == 0) then
			mem_free = count;
			flag = 1;
			[MEM_LIST + mem_free] = 1; //updating mem_free for stack 
			break;
		endif;
		count = count + 1;
	endwhile;

	if (flag == 0) then
		[physicalSP - 2] = -1;  //insufficient memory
		ireturn;
	endif;

	count = 0;
	while(count < 512) do
		[mem_free*512 + count] = [[PTBR + 6]*512 + count];
		count = count + 1;
	endwhile;

	alias newPTBR S6;
	newPTBR = 1024 + 8*child_pid; //use PAGE_TABLE instead of 1024

	[newPTBR + 6] = mem_free; //stack is set
	[newPTBR + 7] = "01";

	alias newPCB S7;
	newPCB = READY_LIST + 32*child_pid;

	count = 0;
	while(count < 3) do
		[newPTBR + 2*count] = [PTBR + 2*count];
		[newPTBR + 2*count + 1] = [PTBR + 2*count + 1];
		if([newPTBR + 2*count + 1] == "01" || [newPTBR + 2*count + 1] == "11") then
			[MEM_LIST + [PTBR + 2*count]] = [MEM_LIST + [PTBR + 2*count]] + 1;
		endif;
		if([newPTBR + 2*count + 1] == "00" && [newPTBR + 2*count] >= 448) then
			[DISK_LIST + [PTBR + 2*count]] = [DISK_LIST + [PTBR + 2*count]] + 1;
			store(6,20);//storing DF back to the disk
		endif;
		count = count + 1;
	endwhile;

	[newPCB  + 2] = BP; 
	[newPCB  + 3] = SP -1;//setting SP;
	[newPCB  + 4] = [physicalSP]; // Setting IP
	[newPCB  + 5] = newPTBR; //setting PTBR of child
	[newPCB  + 6] = PTLR;

//DONOT COPY PARENT'S PCB DIRECTLY
	[newPCB  + 7] = R0;
	[newPCB  + 8] = R1;
	[newPCB  + 9] = R2;
	[newPCB  + 10] = R3;
	[newPCB  + 11] = R4;
	[newPCB  + 12] = R5;
	[newPCB  + 13] = R6;
	[newPCB  + 14] = R7;
	[newPCB  + 31] = parent_pid;
	alias i S8;
	i = 0;

	while (i < 8) do
		[newPCB  + 15 + i*2] = [READY_LIST + ((PTBR - 1024)/8)*32 + 15 + i*2];
		[newPCB  + 15 + i*2+ 1] = [READY_LIST + ((PTBR - 1024)/8)*32 + 15 + i*2 + 1];
		if ([newPCB  + 15 + i*2] != -1) then
			[FILE_TABLE + 2*[newPCB  + 15 + i*2] + 1] = [FILE_TABLE + 2*[newPCB  + 15 + i*2] + 1] + 1;
		endif;
		i = i + 1;
	endwhile;

	[newPCB + 1] = 1;
	[physicalSP - 2] = child_pid; //parent return value

	[[newPTBR + 2*(SP-1)/512]* 512 + (SP -1)%512 - 1] = -2; //child return value
	ireturn;
endif;